---
layout: post
title: Comparing CSV reading and writing functions
description: Demonstrating advantages of data.table
---

```{r Ropts, echo=FALSE, results='hide'}
repo.dir <- normalizePath("..")
post.id <- "2024-12-02-pandas-dt"
fig.path <- paste0(file.path(repo.dir, "assets", "img", post.id), "/")
dir.create(fig.path, showWarnings = FALSE, recursive = TRUE)
knitr::opts_chunk$set(
  dpi=100,
  fig.path=fig.path,
  fig.width=10, ## TODO python figures wider? look at prev issue.
  fig.process=function(path)sub(repo.dir, "", path, fixed=TRUE),
  fig.height=4)
conda.env <- "2023-08-deep-learning"
RETICULATE_PYTHON <- normalizePath(sprintf(if(.Platform$OS.type=="unix")
  ##"/home/tdhock/.local/share/r-miniconda/envs/%s/bin/python"
  "/home/tdhock/miniconda3/envs/%s/bin/python"
  else "~/AppData/Local/miniconda3/envs/%s/python.exe", conda.env))
Sys.setenv(RETICULATE_PYTHON=RETICULATE_PYTHON)
reticulate::use_condaenv(conda.env)
in_render <- !is.null(knitr::opts_knit$get('rmarkdown.pandoc.to'))
in_knit <- isTRUE(getOption('knitr.in.progress'))
options(width=120)
if(FALSE){
  knitr::knit(paste0(post.id, ".Rmd"))
}
```

The goal of this post is to demonstrate that the performance of
`data.table` is competitive with similar libraries available in Python
(pandas, duckdb, polars).

## What is the overhead of communication with python from R?

First, since we will be recording the timings of python code from R,
we will run a test to determine what is the overhead.

```{r overhead}
atime.overhead <- atime::atime(
  N = as.integer(10^seq(0, 3, by = 0.5)),
  overhead = {
    reticulate::py_run_string("x = 5")
  }
)
atime.overhead$unit.col.vec <- c(seconds="median")
plot(atime.overhead)
(overhead.seconds <- median(atime.overhead$measurements$median))
```

The plot above shows that the overhead of communication between R and
python is about `r overhead.seconds*1000`
milliseconds. 

## write csv, vary columns, char

This section compares the performance of CSV files with a variable
number of character/string columns..

```{r write-chr-cols}
library(data.table)
reticulate::py_run_string("import pandas as pd")
N_rows <- 100
(N_col_seq <- unique(as.integer(10^seq(0, 6, by = 0.2))))
main <- reticulate::py
con <- duckdb::dbConnect(duckdb::duckdb(), dbdir = ":memory:")
atime.write.chr.cols <- atime::atime(
  N = N_col_seq,
  setup = {
    input.chr <- matrix(c("foo", "x", "bar", NA), N_rows, N)
    input.df <- data.frame(input.chr)
    polars.df <- polars::as_polars_df(input.df)
    main$input_df_pd <- input.df
    input.dt <- data.table(input.df)
    duckdb::dbWriteTable(con, "duck_table", input.df, overwrite=TRUE)
    out.csv <- sprintf("%s/data_N=%d.csv", tempdir(), N)
  },
  seconds.limit = 0.1,
  "data.table\nfwrite" = {
    data.table::fwrite(input.dt, out.csv, showProgress = FALSE)
  },
  "pandas\nto_csv" = {
    reticulate::py_run_string("input_df_pd.to_csv('data.csv', index=False)")
  },
  "polars\nto_csv" = {
    polars.df$write_csv('polars.csv')
  },
  "duckdb\nCOPY" = { # https://duckdb.org/docs/guides/file_formats/csv_export.html
    DBI::dbSendQuery(con, "COPY duck_table TO 'duck.csv' (HEADER, DELIMITER ',')")
  }
)
atime.write.chr.cols$unit.col.vec <- c(seconds="median")
library(ggplot2)
plot(atime.write.chr.cols)+
  geom_hline(aes(
    yintercept=overhead.seconds),
    color="grey50",
    data=data.frame(overhead.seconds))
```

The plot above shows a colored curve for each CSV writing function.
The grey horizontal line shows the overhead of communication with python from R.
We see that the overhead (grey line) is insignificant, compared with the CSV writing timings (colored curves).
The code below shows the throughput of each function at the specified time limit.

```{r pred-write-chr-cols}
refs.write.chr.cols <- atime::references_best(atime.write.chr.cols)
pred.write.chr.cols <- predict(refs.write.chr.cols)
plot(pred.write.chr.cols)+
  ggtitle("Write strings to CSV, 100 x N")+
  scale_x_log10("N = number of columns to write")+
  scale_y_log10("Computation time (seconds)\nmedian line, min/max band\nover 10 timings",limits=c(1e-4,0.5))+
  facet_null()
```

The plot above shows that `data.table` is competitive with the other
libraries: about 2x faster than polars, and 10x faster than pandas/duckdb.

# read CSV, vary columns, char

In this section we compare performance of CSV readers.

```{r read-chr-cols}
atime.read.chr.cols <- atime::atime(
  N = N_col_seq,
  setup = {
    in.csv <- sprintf("%s/data_N=%d.csv", tempdir(), N)
    pandas_cmd <- sprintf("pd.read_csv('%s')", in.csv)
    ## https://duckdb.org/docs/data/csv/overview.html
    duck_cmd <- sprintf("SELECT * FROM read_csv('%s', delim=',', header=true)", in.csv)
  },
  seconds.limit = 0.1,
  "data.table\nfread" = {
    data.table::fread(in.csv, showProgress = FALSE)
  },
  "pandas\nread_csv" = {
    reticulate::py_run_string(pandas_cmd)
  },
  "duckdb\nread_csv" = {
    DBI::dbSendQuery(con, duck_cmd)
  },
  "polars\nread_csv" = {
    polars::pl$read_csv(in.csv)
  }
)
refs.read.chr.cols <- atime::references_best(atime.read.chr.cols)
pred.read.chr.cols <- predict(refs.read.chr.cols)
plot(pred.read.chr.cols)+
  ggtitle("Read strings from CSV, 100 x N")+
  scale_x_log10("N = number of columns to read")+
  scale_y_log10("Computation time (seconds)\nmedian line, min/max band\nover 10 timings",limits=c(1e-4,0.5))+
  facet_null()
```

The plot above shows that `data.table` has the fastest CSV reader.
The plot above shows the throughput at the time limit, which reveals
that `data.table` is faster than polars by a small factor (less than
2x), but faster than duckdb/pandas by a larger amount (3-5x).

# variants of these benchmarks

There are several variables we can play with in these benchmarks.

* variable number of rows or columns (we did columns above)
* numeric or character/string data (we did character/string above)
* read or write (we did both above)

Below we consider two variants of the benchmark.

## write csv, variable rows

Here we consider writing a variable number of rows (instead of cols above)
for character/string data. (numeric data and reading are exercises for the
reader)

```{r write-chr-rows}
atime.write.chr.rows <- atime::atime(
  setup = {
    input.chr <- matrix(c("foo", "x", "bar", NA), N, 10)
    input.df <- data.frame(input.chr)
    polars.df <- polars::as_polars_df(input.df)
    main$input_df_pd <- input.df
    input.dt <- data.table(input.df)
    duckdb::dbWriteTable(con, "duck_table", input.df, overwrite=TRUE)
    out.csv <- sprintf("%s/data_N=%d.csv", tempdir(), N)
  },
  seconds.limit = 0.01,
  "data.table\nfwrite" = {
    data.table::fwrite(input.dt, out.csv, showProgress = FALSE)
  },
  "pandas\nto_csv" = {
    reticulate::py_run_string("input_df_pd.to_csv('data.csv', index=False)")
  },
  "polars\nto_csv" = {
    polars.df$write_csv('polars.csv')
  },
  "duckdb\nCOPY" = { # https://duckdb.org/docs/guides/file_formats/csv_export.html
    DBI::dbSendQuery(con, "COPY duck_table TO 'duck.csv' (HEADER, DELIMITER ',')")
  }
)
refs.write.chr.rows <- atime::references_best(atime.write.chr.rows)
pred.write.chr.rows <- predict(refs.write.chr.rows)
plot(pred.write.chr.rows)+
  ggtitle("Write strings to CSV, N x 100")+
  scale_y_log10("Computation time (seconds)\nmedian line, min/max band\nover 10 timings")+
  facet_null()+
  scale_x_log10("N = number of rows to write")
```

The plot above again shows that `data.table` is the fastest CSV writer. 
It is about the same as polars (within 2x), 
about 3x faster than duckdb, 
and 10x faster than pandas.

## write csv, numeric cols

Here we consider writing a variable number of cols for numeric data
(instead of character/string data above). Variable number of rows, and
reading instead of writing, are exercises for the reader.

```{r write-num-cols}
atime.write.num.cols <- atime::atime(
  N = N_col_seq,
  setup = {
    set.seed(1)
    input.num <- matrix(rnorm(N_rows * N), N_rows, N)
    input.num[sample(N_rows*N, N)] <- NA
    input.df <- data.frame(input.num)
    polars.df <- polars::as_polars_df(input.df)
    main$input_df_pd <- input.df
    input.dt <- data.table(input.df)
    duckdb::dbWriteTable(con, "duck_table", input.df, overwrite=TRUE)
    out.csv <- sprintf("%s/data_N=%d.csv", tempdir(), N)
  },
  seconds.limit = 0.1,
  "data.table\nfwrite" = {
    data.table::fwrite(input.dt, out.csv, showProgress = FALSE)
  },
  "pandas\nto_csv" = {
    reticulate::py_run_string("input_df_pd.to_csv('data.csv', index=False)")
  },
  "polars\nto_csv" = {
    polars.df$write_csv('polars.csv')
  },
  "duckdb\nCOPY" = { # https://duckdb.org/docs/guides/file_formats/csv_export.html
    DBI::dbSendQuery(con, "COPY duck_table TO 'duck.csv' (HEADER, DELIMITER ',')")
  }
)
refs.write.num.cols <- atime::references_best(atime.write.num.cols)
pred.write.num.cols <- predict(refs.write.num.cols)
plot(pred.write.num.cols)+
  ggtitle("Write real numbers to CSV, 100 x N")+
  scale_y_log10("Computation time (seconds)\nmedian line, min/max band\nover 10 timings",limits=c(1e-4,0.5))+
  facet_null()+
  scale_x_log10("N = number of columns to write")
```

The code above shows the throughput of each function at the specified time limit.
The plot above shows that `data.table` is competitive with the other
libraries: almost as fast as polars, and several times faster than
pandas/duckdb.

# Conclusions

We have shown that `data.table` CSV reading and writing can be faster
than similar libraries which can be used from python or R.  We
observed that `data.table` is especially efficient for
character/string data (rather than numeric data).

# Session info

```{r}
sessionInfo()
```
