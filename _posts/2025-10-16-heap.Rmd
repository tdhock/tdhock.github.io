---
layout: post
title: Heap in R and python
description: Empirical time complexity
---

```{r Ropts, echo=FALSE, results='hide'}
repo.dir <- normalizePath("..")
post.id <- "2025-10-16-heap"
fig.path <- paste0(file.path(repo.dir, "assets", "img", post.id), "/")
dir.create(fig.path, showWarnings = FALSE, recursive = TRUE)
knitr::opts_chunk$set(
  dpi=100,
  fig.path=fig.path,
  fig.width=10, ## TODO python figures wider? look at prev issue.
  fig.process=function(path)sub(repo.dir, "", path, fixed=TRUE),
  fig.height=4)
in_render <- !is.null(knitr::opts_knit$get('rmarkdown.pandoc.to'))
in_knit <- isTRUE(getOption('knitr.in.progress'))
options(width=150)
if(FALSE){
  knitr::knit(paste0(post.id, ".Rmd"))
}
```

Yesterday I was reading the source code for the scikit-learn function
that implements Hierachical clustering with Ward linkage,
[_agglomerative.py](https://github.com/scikit-learn/scikit-learn/blob/c60dae2060/sklearn/cluster/_agglomerative.py). The
python function `ward_tree()` uses functions `heapify()`, `heappop()`,
`heappush()`. The [heapify
docs](https://docs.python.org/3/library/heapq.html#heapq.heapify) say
that it converts a python list (~ C++ STL vector) to a min-heap. Is there an equivalent in R?

## In theory

The basic data structures in R are "vectors" which are in fact more like C++ STL arrays (fixed size).
So in R we could have a large heap that reduces in size (with some unused elements).
If we had a small heap, and we wanted to increase its size, we could use the same trick that python uses to enable its "lists" to support the append operation (allocate a new array double the size and have some unused elements).

## Software

In C++ STL there is [`make_heap()`](https://cplusplus.com/reference/algorithm/make_heap/) which works on any random access iterator (vector or array).
The heap is also used in the [`priority_queue`](https://cplusplus.com/reference/queue/priority_queue/) data structure which I have used to implement efficient binary segmentation in [binsegRcpp/src/binseg.cpp](https://github.com/tdhock/binsegRcpp/blob/master/src/binseg.cpp).

Of course we can call C++ from R or Python.
But can we call an R function like `make_heap()` in C++ or `heapify()` in python?
There was a [datastructures](https://github.com/dirmeier/datastructures) CRAN package, now only on github:

```{r}
remotes::install_github("dirmeier/datastructures")
```

For the application to hierarchical clustering, we want efficient minimization of numeric distances, so we create a heap with numeric keys below.

```{r}
num_heap <- datastructures::fibonacci_heap("numeric")
datastructures::size(num_heap)
```

Above we see that it starts empty (size 0).
Below we insert five simulated distances as keys.

```{r}
set.seed(1)
(dist.vec <- rnorm(5))
datastructures::insert(num_heap, dist.vec, 1:5)
datastructures::size(num_heap)
```

Above we see the size has increased to 5.
Below we pop one item from the heap.

```{r}
datastructures::pop(num_heap)
datastructures::size(num_heap)
```

Above we see that it popped the smallest distance, and the new size is 4.
Below we adapt these methods to an atime performance comparison.

```{r atime-result}
library(data.table)
a_result <- atime::atime(
  setup={
    set.seed(1)
    keys <- rnorm(N)
    values <- 1:N
  },
  data.frame={
    df <- data.frame(keys, values)
    out <- integer(N)
    for(i in 1:N){
      min.row <- which.min(df$keys)
      df$keys[min.row] <- NA
      out[[i]] <- df$values[min.row]
    }
    out
  },
  seconds=1,
  result=TRUE,
  heap={
    num_heap <- datastructures::fibonacci_heap("numeric")
    datastructures::insert(num_heap, keys, values)
    out <- integer(N)
    for(i in 1:N){
      out[[i]] <- datastructures::pop(num_heap)[[1]]
    }
    out
  })
plot(a_result)
```

Above we see that

* for small data sizes, the linear search with a data frame is faster than the heap pop.
* for large data sizes, the heap pop is faster than the linear search with the data frame.
* the asymptotic time and memory usage (slope on the right) is smaller for heap, which indicates a smaller big-O complexity class.

Below we plot reference lines to estimate the big-O classes.

```{r atime-refs}
a_refs <- atime::references_best(a_result)
plot(a_refs)
```

The plot above shows that

* `data.frame` is quadratic `O(N^2)` time and memory.
* `heap` is log-linear `O(N log N)` time and linear `O(N)` memory.

These are the expected results from using a heap versus a vector.

## Conclusions

We have shown that there is an R package `datastructures` which implements the heap, and has expected asymptotic time/space complexity.

## Session info

```{r}
sessionInfo()
```
